# -*- coding: utf-8 -*-
"""EV Powertrain Efficiency Simulator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qLpb1660_StEv8x1HJgwkhPz4tR1rfiG
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

"""
EV Powertrain Efficiency Simulator
Physics-based model of a 60 kWh EV (Tesla Model 3-inspired) over repeated WLTP cycles.
Optimizes mass, aero (Cd), and regen efficiency; outputs range, consumption, and visualizations.
Built as a personal project to explore powertrain KPIs relevant to battery/production optimization.
"""

# EV Parameters (constants)
BATTERY_CAPACITY_KWH = 60
MASS_BASE_KG = 1800
CD_BASE = 0.23
FRONTAL_AREA_M2 = 2.3
CRR = 0.0085  # Rolling resistance coefficient
RHO_AIR = 1.225  # kg/m³
G = 9.81  # m/s²
GRADE_DEG = 0  # Flat road
ETA_INVERTER = 0.95
ETA_REGEN_BASE = 0.60
ACCESSORY_LOAD_KW = 1.5  # Avg auxiliaries (HVAC, electronics, etc.)

def motor_efficiency(p_kW: float) -> float:
    """Motor efficiency curve (peaks ~94%)."""
    if p_kW <= 0:
        return 0.90
    return 0.85 + 0.09 * (1 - np.exp(-abs(p_kW) / 50))

# Approximate WLTP Class 3 cycle (~23-32 km per 1800s cycle, tuned for realism)
CYCLE_DURATION_S = 1800
t_cycle = np.arange(0, CYCLE_DURATION_S + 1, 1)  # 1-second resolution
v_kmh_cycle = np.concatenate([
    np.linspace(0, 50, 300), np.linspace(50, 30, 100),
    np.linspace(30, 80, 400), np.linspace(80, 100, 200),
    np.linspace(100, 131.5, 200), np.linspace(131.5, 90, 200),
    np.linspace(90, 0, 401)
])
v_kmh_cycle = np.clip(v_kmh_cycle[:len(t_cycle)], 0, 140)
v_ms_cycle = v_kmh_cycle * 1000 / 3600

def simulate_range(mass_kg: float = MASS_BASE_KG, cd: float = CD_BASE, eta_regen: float = ETA_REGEN_BASE):
    """Simulate full range by repeating WLTP cycles until SoC <= 5%."""
    soc = 1.0
    total_distance_m = 0.0
    energy_used_kwh = 0.0
    cycle_count = 0

    # Downsampled data for plotting (every 30s + final point)
    soc_history = [soc * 100]
    v_history_kmh = [v_kmh_cycle[0]]
    t_history_min = [0.0]

    grade_rad = np.deg2rad(GRADE_DEG)  # Pre-compute

    while soc > 0.05:
        cycle_count += 1
        for i in range(1, len(t_cycle)):
            dt = 1.0
            v = v_ms_cycle[i]
            a = (v_ms_cycle[i] - v_ms_cycle[i-1]) / dt

            # Road loads (N) --> power at wheels (kW)
            f_drag = 0.5 * RHO_AIR * cd * FRONTAL_AREA_M2 * v**2
            f_roll = CRR * mass_kg * G * np.cos(grade_rad) * v
            f_accel = mass_kg * a * v
            f_grade = mass_kg * G * np.sin(grade_rad) * v
            p_wheel_kw = (f_drag + f_roll + f_accel + f_grade) / 1000

            # Traction vs regen
            if a < -0.5 and v > 5:  # Braking regen
                p_bat_traction_kw = -p_wheel_kw * eta_regen
            else:
                eta_m = motor_efficiency(p_wheel_kw)
                p_bat_traction_kw = p_wheel_kw / (eta_m * ETA_INVERTER) if p_wheel_kw > 0 else 0

            # Add constant accessory load
            p_bat_kw = p_bat_traction_kw + ACCESSORY_LOAD_KW

            energy_delta_kwh = p_bat_kw * (dt / 3600)
            energy_used_kwh += max(energy_delta_kwh, 0)
            soc -= energy_delta_kwh / BATTERY_CAPACITY_KWH
            soc = max(0, soc)

            total_distance_m += v * dt

            # Downsample every 30s
            if t_cycle[i] % 30 == 0:
                current_time_min = (cycle_count - 1) * 30 + t_cycle[i] / 60
                soc_history.append(soc * 100)
                v_history_kmh.append(v_kmh_cycle[i])
                t_history_min.append(current_time_min)

            if soc <= 0.05:
                # Add final depletion point
                soc_history.append(soc * 100)
                v_history_kmh.append(v_kmh_cycle[i])
                t_history_min.append((cycle_count - 1) * 30 + t_cycle[i] / 60)
                break

        if soc <= 0.05:
            break

    range_km = total_distance_m / 1000
    consumption_wh_km = (energy_used_kwh * 1000) / range_km if range_km > 0 else 0
    return range_km, soc, consumption_wh_km, soc_history, v_history_kmh, t_history_min

if __name__ == "__main__":
    # Baseline simulation
    baseline_range, _, baseline_cons, soc_hist, v_hist, t_plot = simulate_range()
    print(f"Baseline Range: {baseline_range:.1f} km | Consumption: {baseline_cons:.0f} Wh/km")

    # Optimization configs
    configs = [
        ("Baseline", MASS_BASE_KG, CD_BASE, ETA_REGEN_BASE),
        ("Opt1: -10% Mass (Lower CoG)", MASS_BASE_KG * 0.9, CD_BASE, ETA_REGEN_BASE),
        ("Opt2: -8% Aero (Cd)", MASS_BASE_KG, CD_BASE * 0.92, ETA_REGEN_BASE),
        ("Opt3: +15% Regen", MASS_BASE_KG, CD_BASE, ETA_REGEN_BASE + 0.09),
        ("Opt Full: All Combined", MASS_BASE_KG * 0.9, CD_BASE * 0.92, ETA_REGEN_BASE + 0.09)
    ]

    results = []
    for name, mass, cd_val, regen in configs:
        rng, _, cons, _, _, _ = simulate_range(mass, cd_val, regen)
        gain_pct = (rng - baseline_range) / baseline_range * 100
        results.append({
            "Config": name,
            "Range (km)": round(rng),
            "Cons (Wh/km)": round(cons),
            "% Gain": round(gain_pct, 1)
        })

    df = pd.DataFrame(results)
    print("\n", df)

    # Visualization
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 9))

    ax1.plot(t_plot, v_hist, 'b-', lw=2, label='Velocity (km/h)')
    ax1.set_ylabel('Velocity (km/h)')
    ax1.set_xlabel('Time (minutes)')
    ax1.grid(True)

    ax1_twin = ax1.twinx()
    ax1_twin.plot(t_plot, soc_hist, 'r-', lw=2, label='SoC (%)')
    ax1_twin.set_ylabel('SoC (%)')

    ax1.set_title('Repeated WLTP Cycles: Velocity & Battery SoC')
    ax1.legend(loc='upper left')
    ax1_twin.legend(loc='upper right')

    colors = ['gray', 'teal', 'teal', 'teal', 'darkgreen']
    ax2.bar(df['Config'], df['Range (km)'], color=colors)
    ax2.set_ylabel('Range (km)')
    ax2.set_title('Optimization Results')
    ax2.tick_params(axis='x', rotation=20)
    for i, row in df.iterrows():
        ax2.text(i, row['Range (km)'] + 8, f"+{row['% Gain']}%", ha='center', fontsize=11)

    plt.tight_layout()
    plt.savefig('ev_powertrain_results.png', dpi=300)
    plt.close()
    print("\nPlot saved as 'ev_powertrain_results.png'!")